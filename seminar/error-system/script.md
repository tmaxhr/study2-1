# 화면 1 (START)

인사, 주제 소개

# 화면 2

에러 어떻게 처리하고 있나요?

# 화면 3

대부분은 이렇게 try-catch를 사용할 것이라고 생각함

# 화면 4

또 이렇게 에러가 발생할 때마다 던지는 경우도 있음. 하지만 이 경우에는 어디로 던지는 걸까? 인지하면서 던지는 경우는 많지 않음

또한 모든 api에 대해서 이렇게 던지는 에러를 catch 해주는 것은 휴먼 에러의 가능성을 배제할 수 없다.

이렇게 던지는데 받는 부분이 없게되면, 사용자가 흰 화면을 보게 될 가능성이 있음.

따라서

- 에러가 어떤 경우에 발생하는지
- 어디서 에러를 처리할 것인지

를 정리하는게 우선이라고 생각했다.

# 화면 5

그럼 먼저 에러를 정리해보자. 어떤 경우에 에러가 발생할까

# 화면 6

제일 먼저 생각나는건 api 호출이 실패했을 때.

원인은 네트워크 오류, fetch 자체가 실패했을 때, 서버에서 응답은 왔지만 성공하지 않았을 경우 등 다양한 경우가 있음

# 화면 7

잘못된 데이터를 접근하는 경우가 있다. 물론 현재 Typescript를 쓰면서 어느정도 런타임 시의 에러를 방지하고 있지만, 종종 발생한다.

# 화면 8

결국 에러들을 어떻게 해결할지를 고민하는건 UX를 고민하는 것과 같다.

우리가 이런 고민들을 하는 이유는 런타임에서 발생하는 에러들을 줄이고, 사용자에게 보다 더 나은 경험을 제공해주기 위한 것

# 화면 9

그럼 어떻게 처리했을까

1. 우리는 이런 에러 처리에 있어 권장되는 방식이 있는지,
2. 여러 에러들을 어떻게 분류해 처리할지

고민했다.

# 화면 10

리액트 공식 문서에서는 Error boundary를 권장하고 있는데, 우리 역시 이를 이용하였다.

# 화면 11

그래서 Error boundary를 통해 아래와 같은 에러들을 적절히 분류해 처리하고자 했다.

# 화면 12

이 Error boundary를 우리는 RootBoundary, PageBoundary 두 개의 바운더리로 나누었다.

PageBoundary는 페이지 별로 특정 에러에 대한 처리를 할 경우에 사용한다. (alert를 띄워주거나, 특정 페이지로 이동하는 등 어떠한 동작을 해야 하는 경우)

더 상위 스코프로 에러가 전파되지 않으므로, 페이지가 refresh 되거나 하는 일이 없다. (form들 다시 다 채우려면 매우 화날 수 있음)

RootBoundary는 전역에서 에러를 처리한다.

PageBoundary에 걸리지 않은 에러들은 여기에서 catch 하게 된다.

여기에서 `별도로 처리하지 못한 에러` 라는 것은 런타임에서 예측하지 못하게 발생한 에러들을 말함

# 화면 13

page boundary 코드 간략화 버전, 설명

# 화면 14

root boundary 코드 설명, 슬랙에 로깅과 page500으로 라우팅 하는 코드만 있음

여기서 react-error-boundary 사용 이유를 여기서 말해도 되지 않을까

# 화면 15

Error boundary에서는 비동기 작업(setTimeout같은)과 이벤트 핸들러에서 발생한 에러는 캐치하지 못한다.

# 화면 16

이를 위해 전역에 이벤트 핸들러를 붙여놨다. error event가 발생하면 해당 effect에서 에러를 캐치하고, error boundary를 트리거한다.

# 화면 17

에러 처리를 해놓으면 빠른 대응을 위해, 모니터링 할 수 있는 방법이 있어야 할 것이다.

- sentry와 같은 로깅 툴은 너무 오버스펙

- 간단히 에러만 알려주고, 해당되는 인원들에게 notify 할 용도로 슬랙을 활용

- 별도의 프록시 서버에 띄웠음 (로컬에서는 안돌리고, 스테이징이나 qa 용도)

# 화면 18

프록시 서버를 왜 사용할까?
프록시를 사용하는 잘 알려진 이유로는 캐싱을 통한 성능, 보안 두 가지를 챙기기 위해서다.

- http 와 https 간 통신 문제

- slack webhook url을 프록시 서버가 가져 클라이언트가 직접 이를 알 수 없게 함

리버스 프록시를 둔 것이라고 보면 된다.

# 화면 19

또한 아까 말했던, 페이지 단위로 에러를 처리하는 PageBoundary에서도 로깅을 하고 싶다면 log 값을 true로 설정해 로깅을 할 수 있다.

# 화면 20

오류코드로 어느 도메인에서 발생하는 오류인지 알기 편리하며, 어떤 오류가 발생한 것인지 로그로 확인하고 소통할 수 있음

도메인별로 처리 방식을 다르게 진행 가능 (도메인 별로 에러 시 보여지는 화면이 다르다던가, 로깅에 태그되는 인원을 다르게 한다던가)

# 화면 21

이렇게 한다면 앞서 말했던 PageBoundary에 domain별 에러를 처리하는 로직을 추가하면 된다.

# 화면 22 (FIN)

에러 처리는 서비스가 실 사용자에게 서빙될 때 빠져서는 안되는 필수 기능이라고 생각함.

프론트는 사용자와 직접 맞닿는 영역이기 때문에, 적절한 에러 처리는 UX의 향상 뿐만 아니라 서비스에 대한 완성도와 신뢰도 또한 높여줄 수 있음.

굳이 우리의 방법이 아니더라도, 사내 다양한 프로젝트에서 에러에 대한 고민을 한 번쯤은 고려해보면 좋겠다.
